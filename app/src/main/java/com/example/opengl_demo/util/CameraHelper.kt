package com.example.opengl_demo.util

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.graphics.ImageFormat
import android.graphics.Point
import android.graphics.SurfaceTexture
import android.hardware.camera2.*
import android.media.ImageReader
import android.media.ImageReader.OnImageAvailableListener
import android.os.Handler
import android.os.HandlerThread
import android.util.Log
import android.util.Size
import android.view.Surface
import android.view.WindowManager
import java.util.*

class CameraHelper(private val mContext: Context) {
    private val TAG = "CameraHelper"
    private var mCameraId: String? = null
    private var onPreviewSizeListener: OnPreviewSizeListener? = null
    private lateinit var imageReader: ImageReader
    private var onPreviewListener: OnPreviewListener? = null
    private var mWidth = 0
    private var mHeight = 0

    /**
     * The [android.util.Size] of camera preview.
     */
    private var size: Size? = null

    /**
     * [CaptureRequest.Builder] for the camera preview
     */
    private var mPreviewRequestBuilder: CaptureRequest.Builder? = null
    private var mSurfaceTexture: SurfaceTexture? = null
    private var mCameraDevice: CameraDevice? = null

    /**
     * An additional thread for running tasks that shouldn't block the UI.
     */
    private var mBackgroundThread: HandlerThread? = null

    /**
     * A [Handler] for running tasks in the background.
     */
    private var mBackgroundHandler: Handler? = null

    /**
     * A [CameraCaptureSession] for camera preview.
     */
    private var mCaptureSession: CameraCaptureSession? = null
    /**
     * Opens the camera specified .
     */
    /**
     * [CaptureRequest] generated by [.mPreviewRequestBuilder]
     */
    private var mPreviewRequest: CaptureRequest? = null
    fun openCamera(width: Int, height: Int, mSurfaceTexture: SurfaceTexture?) {
        this.mSurfaceTexture = mSurfaceTexture
        startBackgroundThread()

        //设置预览图像的大小，surfaceview的大小。
        setUpCameraOutputs(width, height)
        val manager = mContext.getSystemService(Context.CAMERA_SERVICE) as CameraManager
        try {
            if (mContext.checkSelfPermission(Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
                // TODO: Consider calling
                //    Activity#requestPermissions
                // here to request the missing permissions, and then overriding
                //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
                //                                          int[] grantResults)
                // to handle the case where the user grants the permission. See the documentation
                // for Activity#requestPermissions for more details.
                return
            }
            manager.openCamera(mCameraId!!, mStateCallback, mBackgroundHandler)
        } catch (e: CameraAccessException) {
            e.printStackTrace()
        }
    }

    val cameraId: Int
        get() = Integer.valueOf(mCameraId!!)

    /**
     * Closes the current [CameraDevice].
     */
    fun closeCamera() {
        if (null != mCaptureSession) {
            mCaptureSession!!.close()
            mCaptureSession = null
        }
        if (null != mCameraDevice) {
            mCameraDevice!!.close()
            mCameraDevice = null
        }

//        if (mSurfaceTexture != null) {
//            mSurfaceTexture.release();
//            mSurfaceTexture = null;
//        }
        stopBackgroundThread()
    }

    /**
     * Starts a background thread and its [Handler].
     */
    private fun startBackgroundThread() {
        mBackgroundThread = HandlerThread("CameraBackground")
        mBackgroundThread!!.start()
        mBackgroundHandler = Handler(mBackgroundThread!!.looper)
    }

    /**
     * Stops the background thread and its [Handler].
     */
    private fun stopBackgroundThread() {
        mBackgroundThread!!.quitSafely()
        try {
            mBackgroundThread!!.join()
            mBackgroundThread = null
            mBackgroundHandler = null
        } catch (e: InterruptedException) {
            e.printStackTrace()
        }
    }

    /**
     * Sets up member variables related to camera.
     *
     * @param width  The width of available size for camera preview
     * @param height The height of available size for camera preview
     */
    private fun setUpCameraOutputs(width: Int, height: Int) {
        val manager = mContext.getSystemService(Context.CAMERA_SERVICE) as CameraManager
        try {
            for (cameraId in manager.cameraIdList) {
                val characteristics = manager.getCameraCharacteristics(cameraId)

                // We don't use a front facing camera in this sample.
                val facing = characteristics.get(CameraCharacteristics.LENS_FACING)
                if (facing != null && facing == CameraCharacteristics.LENS_FACING_BACK) {
                    continue
                }
                val map = characteristics.get(
                    CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP
                )
                    ?: continue
                val displaySize = Point()
                val mWindowManager = mContext.getSystemService(Context.WINDOW_SERVICE) as WindowManager
                mWindowManager.defaultDisplay.getSize(displaySize)
                val maxPreviewWidth = displaySize.x
                val maxPreviewHeight = displaySize.y
                val largest = Collections.max(
                    listOf(*map.getOutputSizes(ImageFormat.YUV_420_888)),
                    CompareSizesByArea()
                )
                // Danger, W.R.! Attempting to use too large a preview size could  exceed the camera
                // bus' bandwidth limitation, resulting in gorgeous previews but the storage of
                // garbage capture data.
                size = chooseOptimalSize(
                    map.getOutputSizes(
                        SurfaceTexture::class.java
                    ),
                    width, height, maxPreviewWidth,
                    maxPreviewHeight, largest
                )
                if (onPreviewSizeListener != null) {
                    onPreviewSizeListener!!.onSize(size!!.width, size!!.height)
                }
                imageReader =
                    ImageReader.newInstance(size!!.width, size!!.height, ImageFormat.YUV_420_888, 2)
                imageReader.setOnImageAvailableListener(
                    mOnImageAvailableListener,
                    mBackgroundHandler
                )
                mCameraId = cameraId
                return
            }
        } catch (e: CameraAccessException) {
            e.printStackTrace()
        } catch (e: NullPointerException) {
        }
    }

    /**
     * [CameraDevice.StateCallback] is called when [CameraDevice] changes its state.
     */
    private val mStateCallback: CameraDevice.StateCallback = object : CameraDevice.StateCallback() {
        override fun onOpened(cameraDevice: CameraDevice) {
            // This method is called when the camera is opened.  We start camera preview here.
            mCameraDevice = cameraDevice
            createCameraPreviewSession()
        }

        override fun onDisconnected(cameraDevice: CameraDevice) {
            cameraDevice.close()
            mCameraDevice = null
        }

        override fun onError(cameraDevice: CameraDevice, error: Int) {
            cameraDevice.close()
            mCameraDevice = null
        }
    }

    /**
     * Creates a new [CameraCaptureSession] for camera preview.
     */
    private fun createCameraPreviewSession() {
        try {

            // This is the output Surface we need to start preview.
            mSurfaceTexture!!.setDefaultBufferSize(size!!.width, size!!.height)
            val surface = Surface(mSurfaceTexture)

            // We set up a CaptureRequest.Builder with the output Surface.
            mPreviewRequestBuilder =
                mCameraDevice!!.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW)
            mPreviewRequestBuilder!!.addTarget(surface)
            mPreviewRequestBuilder!!.addTarget(imageReader.surface)

            // Here, we create a CameraCaptureSession for camera preview.
            mCameraDevice!!.createCaptureSession(
                listOf(surface, imageReader.surface),
                object : CameraCaptureSession.StateCallback() {
                    override fun onConfigured(cameraCaptureSession: CameraCaptureSession) {
                        // The camera is already closed
                        if (null == mCameraDevice) {
                            return
                        }

                        // When the session is ready, we start displaying the preview.
                        mCaptureSession = cameraCaptureSession
                        try {
                            // Auto focus should be continuous for camera preview.
                            mPreviewRequestBuilder!!.set(
                                CaptureRequest.CONTROL_AF_MODE,
                                CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE
                            )
                            // Flash is automatically enabled when necessary.

                            // Finally, we start displaying the camera preview.
                            mPreviewRequest = mPreviewRequestBuilder!!.build()
                            mCaptureSession!!.setRepeatingRequest(
                                mPreviewRequest!!,
                                mCaptureCallback, mBackgroundHandler
                            )
                        } catch (e: CameraAccessException) {
                            e.printStackTrace()
                        }
                    }

                    override fun onConfigureFailed(
                        cameraCaptureSession: CameraCaptureSession
                    ) {
                        Log.d(TAG, "onConfigureFailed: ")
                    }
                }, null
            )
        } catch (e: CameraAccessException) {
            e.printStackTrace()
        }
    }

    /**
     * A [CameraCaptureSession.CaptureCallback] that handles events related to JPEG capture.
     */
    private val mCaptureCallback: CameraCaptureSession.CaptureCallback = object : CameraCaptureSession.CaptureCallback() {
        override fun onCaptureProgressed(
            session: CameraCaptureSession,
            request: CaptureRequest,
            partialResult: CaptureResult
        ) {
        }

        override fun onCaptureCompleted(
            session: CameraCaptureSession,
            request: CaptureRequest,
            result: TotalCaptureResult
        ) {
        }
    }

    fun setPreviewSizeListener(onPreviewSizeListener: OnPreviewSizeListener?) {
        this.onPreviewSizeListener = onPreviewSizeListener
    }

    /**
     * Compares two `Size`s based on their areas.
     */
    internal class CompareSizesByArea : Comparator<Size> {
        override fun compare(lhs: Size, rhs: Size): Int {
            // We cast here to ensure the multiplications won't overflow
            return java.lang.Long.signum(
                lhs.width.toLong() * lhs.height -
                        rhs.width.toLong() * rhs.height
            )
        }
    }

    private val mOnImageAvailableListener =
        OnImageAvailableListener { reader ->
            val image = reader.acquireNextImage() ?: return@OnImageAvailableListener
            val planes = image.planes
            val width = image.width
            val height = image.height
            val yBytes = ByteArray(width * height)
            val uBytes = ByteArray(width * height / 4)
            val vBytes = ByteArray(width * height / 4)
            val i420 = ByteArray(width * height * 3 / 2)
            for (i in planes.indices) {
                var dstIndex = 0
                //val uIndex = 0
                //val vIndex = 0
                val pixelStride = planes[i].pixelStride
                val rowStride = planes[i].rowStride
                val buffer = planes[i].buffer
                val bytes = ByteArray(buffer.capacity())
                buffer[bytes]
                var srcIndex = 0
                when (i) {
                    0 -> {
                        for (j in 0 until height) {
                            System.arraycopy(bytes, srcIndex, yBytes, dstIndex, width)
                            srcIndex += rowStride
                            dstIndex += width
                        }
                    }
                    1 -> {
                        for (j in 0 until height / 2) {
                            for (k in 0 until width / 2) {
                                uBytes[dstIndex++] = bytes[srcIndex]
                                srcIndex += pixelStride
                            }
                            if (pixelStride == 2) {
                                srcIndex += rowStride - width
                            } else if (pixelStride == 1) {
                                srcIndex += rowStride - width / 2
                            }
                        }
                    }
                    2 -> {
                        for (j in 0 until height / 2) {
                            for (k in 0 until width / 2) {
                                vBytes[dstIndex++] = bytes[srcIndex]
                                srcIndex += pixelStride
                            }
                            if (pixelStride == 2) {
                                srcIndex += rowStride - width
                            } else if (pixelStride == 1) {
                                srcIndex += rowStride - width / 2
                            }
                        }
                    }
                }
                System.arraycopy(yBytes, 0, i420, 0, yBytes.size)
                System.arraycopy(uBytes, 0, i420, yBytes.size, uBytes.size)
                System.arraycopy(vBytes, 0, i420, yBytes.size + uBytes.size, vBytes.size)
                if (onPreviewListener != null) {
                    onPreviewListener!!.onPreviewFrame(i420, i420.size)
                }
            }
            image.close()
        }

    fun setOnPreviewListener(onPreviewListener: OnPreviewListener?) {
        this.onPreviewListener = onPreviewListener
    }

    fun getPreviewSize() : Size? {
        return size
    }

    fun getCameraID(): Int {
        return cameraId
    }

    fun getWidth(): Int {
        return size!!.width
    }

    fun getHeight(): Int {
        return size!!.height
    }

    interface OnPreviewSizeListener {
        fun onSize(width: Int, height: Int)
    }

    interface OnPreviewListener {
        fun onPreviewFrame(data: ByteArray?, len: Int)
    }


    companion object {
        /**
         * Camera state: Showing camera preview.
         */
        private const val STATE_PREVIEW = 0

        /**
         * Camera state: Waiting for the focus to be locked.
         */
        private const val STATE_WAITING_LOCK = 1

        /**
         * Camera state: Waiting for the exposure to be precapture state.
         */
        private const val STATE_WAITING_PRECAPTURE = 2

        /**
         * Camera state: Waiting for the exposure state to be something other than precapture.
         */
        private const val STATE_WAITING_NON_PRECAPTURE = 3

        /**
         * Camera state: Picture was taken.
         */
        private const val STATE_PICTURE_TAKEN = 4

        /**
         * Max preview width that is guaranteed by Camera2 API
         */
        private const val MAX_PREVIEW_WIDTH = 1920

        /**
         * Max preview height that is guaranteed by Camera2 API
         */
        private const val MAX_PREVIEW_HEIGHT = 1080

        /**
         * Given `choices` of `Size`s supported by a camera, choose the smallest one that
         * is at least as large as the respective texture view size, and that is at most as large as the
         * respective max size, and whose aspect ratio matches with the specified value. If such size
         * doesn't exist, choose the largest one that is at most as large as the respective max size,
         * and whose aspect ratio matches with the specified value.
         *
         * @param choices           The list of sizes that the camera supports for the intended output
         * class
         * @param textureViewWidth  The width of the texture view relative to sensor coordinate
         * @param textureViewHeight The height of the texture view relative to sensor coordinate
         * @param maxWidth          The maximum width that can be chosen
         * @param maxHeight         The maximum height that can be chosen
         * @param aspectRatio       The aspect ratio
         * @return The optimal `Size`, or an arbitrary one if none were big enough
         */
        private fun chooseOptimalSize(
            choices: Array<Size>, textureViewWidth: Int,
            textureViewHeight: Int, maxWidth: Int, maxHeight: Int, aspectRatio: Size
        ): Size {

            // Collect the supported resolutions that are at least as big as the preview Surface
            val bigEnough: MutableList<Size> = ArrayList()
            // Collect the supported resolutions that are smaller than the preview Surface
            val notBigEnough: MutableList<Size> = ArrayList()
            val w = aspectRatio.width
            val h = aspectRatio.height
            for (option in choices) {
                Log.i("CameraHelper:",option.toString())
                if (option.width <= maxWidth && option.height <= maxHeight && option.height == option.width * h / w) {
                    if (option.width >= textureViewWidth &&
                        option.height >= textureViewHeight
                    ) {
                        bigEnough.add(option)
                    } else {
                        notBigEnough.add(option)
                    }
                }
            }

            // Pick the smallest of those big enough. If there is no one big enough, pick the
            // largest of those not big enough.
            return when {
                bigEnough.size > 0 -> {
                    Collections.min(bigEnough, CompareSizesByArea())
                }
                notBigEnough.size > 0 -> {
                    Collections.max(notBigEnough, CompareSizesByArea())
                }
                else -> {
                    Log.e("Camera2Helper", "Couldn't find any suitable preview size")
                    choices[0]
                }
            }
        }
    }
}
